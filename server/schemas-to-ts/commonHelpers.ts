import prettier from 'prettier';
import { PluginConfig } from "../models/pluginConfig";
import { pluginName } from '../models/pluginName';
import { SchemaInfo } from '../models/schemaInfo';
import { SchemaSource } from '../models/schemaSource';
import { Logger } from './logger';

export class CommonHelpers {
  public readonly logger: Logger;
  constructor(private config: PluginConfig, private readonly strapiRootPath: string) {
    this.logger = new Logger(config.logLevel);
  }

  public async getPrettierOptions(): Promise<prettier.Options | undefined> {
    if (!this.config.usePrettierIfAvailable) {
      return undefined;
    }

    const prettierConfigFile = await prettier.resolveConfigFile(this.strapiRootPath);
    if (prettierConfigFile !== null) {
      return await prettier.resolveConfig(prettierConfigFile, { editorconfig: true });
    }
  }

  public getFileNameFromSchema(schemaInfo: SchemaInfo, withExtension: boolean): string {
    let fileName: string = schemaInfo.source === SchemaSource.Api
      ? schemaInfo.schema.info.singularName
      : schemaInfo.pascalName;

    if (!!withExtension) {
      fileName += '.ts';
    }

    return fileName;
  }

  public static isWindows(): boolean {
    return process.platform === 'win32';
  }

  public static capitalizeFirstLetter(text: string): string {
    return text.charAt(0).toUpperCase() + text.slice(1);
  }

  public static compareIgnoringLineBreaks(str1: string, str2: string): boolean {
    function trimLineBreaks(str: string): string {
      return str.replaceAll('\n', '').trim();
    }
    const normalizedStr1 = trimLineBreaks(str1);
    const normalizedStr2 = trimLineBreaks(str2);

    return normalizedStr1 === normalizedStr2;
  }

  public readonly headerComment: string = CommonHelpers.headerComment;

  public static readonly headerComment: string =
    `// Interface automatically generated by ${pluginName}\n\n`;
}